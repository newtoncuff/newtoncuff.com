from functools import wraps
from flask import request, current_app, jsonify, make_response
from .Service import RedisCache
from datetime import datetime
from . import get_redis

import json
import hashlib

"""<-----Method Docstring
Cache decorator for Flask views

Args:
    timeout (int): Cache timeout in seconds
    key_prefix (str): Prefix for cache key
"""
def cached(timeout=300, key_prefix='view'):

    """<-----Method Docstring
    A decorator to cache the response of a Flask view function using Redis.
    This decorator generates a unique cache key based on the function name, 
    request path, and request arguments. It attempts to retrieve the cached 
    response from Redis and serves it if available. If the response is not 
    cached, it executes the function, caches the result, and serves it.
    Headers are added to the response to indicate cache status, including 
    whether the response was a cache hit or miss. The decorator also handles 
    cache control headers from the client but ignores "no-cache" and "no-store" 
    directives.
    
    Args:
        f (function): The Flask view function to be decorated.
    
    Returns:
        function: The decorated function with caching functionality.
    
    Raises:
        Exception: If there is an error while interacting with the Redis cache.
    
    Notes:
        - The decorator respects the `DISABLE_CACHE_IN_DEBUG` configuration 
            setting when `current_app.debug` is enabled.
        - Cache is only set for GET requests.
        - Adds detailed headers for debugging purposes when `current_app.debug` 
            is enabled.
    """
    def decorator(f):

        """<-----Method Docstring
        A decorator function that implements caching for Flask routes using Redis. It attempts to retrieve
        a cached response for the given request and, if unavailable, executes the wrapped function and caches
        the response for future use.
        The cache key is generated based on the key prefix, function name, request path, and request arguments.
        Headers are added to the response to indicate cache status (HIT or MISS), cache control, and other
        metadata. The function also handles browser cache bypass requests but ignores them.
        Args:
            *args: Positional arguments passed to the wrapped function.
            **kwargs: Keyword arguments passed to the wrapped function.
        Returns:
            Response: A Flask response object, either retrieved from the cache or freshly generated by the
            wrapped function.
        Raises:
            Exception: Logs errors if there are issues with Redis cache retrieval or storage.
        Notes:
            - The cache is only enabled if a Redis client is available.
            - Cache is only set for GET requests.
            - Debug mode adds additional headers for debugging purposes.
            - The cache timeout and key prefix are configurable.
        """
        @wraps(f)
        def decorated_function(*args, **kwargs):

            # Create cache key
            cache_key = f"{key_prefix}:{f.__name__}:{request.path}:{hash(frozenset(request.args.items()))}"
            
            # if current_app.debug and current_app.config.get('DISABLE_CACHE_IN_DEBUG', False):
            #    return f(*args, **kwargs)

            # IMPORTANT: Check if browser wants to bypass cache, but IGNORE this preference
            cache_control = request.headers.get('Cache-Control', '')
            if 'no-cache' in cache_control or 'no-store' in cache_control:
                current_app.logger.info(f"Browser requested cache bypass, but we're ignoring that")

            # Get Redis client
            redis_client = get_redis()
            cache_enabled = redis_client is not None
            
            if cache_enabled:
                # Try to get from cache
                try:
                    cached_response = RedisCache.get(cache_key)
                    if cached_response:
                        current_app.logger.info(f"CACHE HIT: {request.path}")
                        
                        # Create response
                        if isinstance(cached_response, str):
                            response = make_response(cached_response)
                        elif isinstance(cached_response, dict) or isinstance(cached_response, list):
                            response = jsonify(cached_response)
                        else:
                            response = make_response(str(cached_response))
                        
                        # Add headers
                        response.headers['Cache-Control'] = f'max-age={timeout}, public'
                        response.headers['X-Cache'] = 'HIT'
                        response.headers['X-Cache-Status'] = 'HIT'

                        if current_app.debug:
                            response.headers['X-Cache'] = 'HIT'
                            response.headers['X-Cache-Status'] = 'HIT'
                            response.headers['X-Cache-Key'] = cache_key
                            response.headers['X-Request-Method'] = request.method
                            response.headers['X-Cache-Control'] = request.headers.get('Cache-Control', 'none')
                        else:
                            response.headers.pop('X-Cache', None)
                            response.headers.pop('X-Cache-Status', None)
                            response.headers.pop('X-Cache-Key', None)
                            response.headers.pop('X-Request-Method', None)
                            response.headers.pop('X-Cache-Control', None)
                                               
                        if 'X-Cache' in response.headers and response.headers['X-Cache'] == 'HIT':
                            ttl = redis_client.ttl(cache_key)
                            response.headers['Age'] = str(timeout - ttl if ttl > 0 else 0)
                        else:
                            response.headers['Age'] = '0'

                        response.headers['X-Cache-Hit'] = 'true'
                        response.headers['Via'] = 'Flask-Redis-Cache/1.0'
                        response.headers['ETag'] = f'W/"{hash(cache_key)}"'
                        
                        # Log headers being set
                        current_app.logger.info(f"Setting cache HIT headers: {dict(response.headers)}")
                        
                        return response
                except Exception as e:
                    current_app.logger.error(f"Cache get error: {str(e)}")
                    cache_enabled = False
            
            # Execute the function for a fresh response
            current_app.logger.info(f"CACHE MISS: {request.path}")
            response = f(*args, **kwargs)
            
            # Add headers even if cache is disabled
            if hasattr(response, 'headers'):
                response.headers['Cache-Control'] = f'max-age={timeout}, public'
                response.headers['X-Cache'] = 'MISS'
                response.headers['X-Cache-Status'] = 'MISS'
                response.headers['X-Cache-Hit'] = 'false'
                response.headers['Via'] = 'Flask-Redis-Cache/1.0'
                response.headers['ETag'] = f'W/"{hash(cache_key)}"'
                response.headers['X-Cache-Key'] = cache_key
                response.headers['X-Request-Method'] = request.method
                response.headers['X-Cache-Control'] = request.headers.get('Cache-Control', 'none')
                
                # Log headers being set
                current_app.logger.info(f"Setting cache MISS headers: {dict(response.headers)}")
            
            # Cache the response if possible
            if cache_enabled and request.method == 'GET':
                try:
                    if hasattr(response, 'get_data'):
                        data = response.get_data(as_text=True)
                        RedisCache.set(cache_key, data, timeout)
                        current_app.logger.info(f"Setting cache w/Data headers")
                    else:
                        RedisCache.set(cache_key, response, timeout)
                        current_app.logger.info(f"Setting cache without data headers")
                except Exception as e:
                    current_app.logger.error(f"Cache set error: {str(e)}")
                    
            
            return response
        return decorated_function
    return decorator